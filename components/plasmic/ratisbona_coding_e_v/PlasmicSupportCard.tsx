// @ts-nocheck
/* eslint-disable */
/* tslint:disable */
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: 2uxAq5bBM7QPimw2pErK3f
// Component: hP5sxMa1ug
import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";

import * as p from "@plasmicapp/react-web";
import * as ph from "@plasmicapp/host";

import {
  hasVariant,
  classNames,
  wrapWithClassName,
  createPlasmicElementProxy,
  makeFragment,
  MultiChoiceArg,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  pick,
  omit,
  useTrigger,
  StrictProps,
  deriveRenderOpts,
  ensureGlobalVariants
} from "@plasmicapp/react-web";

import "@plasmicapp/react-web/lib/plasmic.css";

import projectcss from "./plasmic_ratisbona_coding_e_v.module.css"; // plasmic-import: 2uxAq5bBM7QPimw2pErK3f/projectcss
import sty from "./PlasmicSupportCard.module.css"; // plasmic-import: hP5sxMa1ug/css

export type PlasmicSupportCard__VariantMembers = {};

export type PlasmicSupportCard__VariantsArgs = {};
type VariantPropType = keyof PlasmicSupportCard__VariantsArgs;
export const PlasmicSupportCard__VariantProps = new Array<VariantPropType>();

export type PlasmicSupportCard__ArgsType = {
  children?: React.ReactNode;
  slot?: React.ReactNode;
};

type ArgPropType = keyof PlasmicSupportCard__ArgsType;
export const PlasmicSupportCard__ArgProps = new Array<ArgPropType>(
  "children",
  "slot"
);

export type PlasmicSupportCard__OverridesType = {
  root?: p.Flex<"div">;
  badge?: p.Flex<"div">;
  card?: p.Flex<"div">;
  freeBox?: p.Flex<"div">;
};

export interface DefaultSupportCardProps {
  children?: React.ReactNode;
  slot?: React.ReactNode;
  className?: string;
}

function PlasmicSupportCard__RenderFunc(props: {
  variants: PlasmicSupportCard__VariantsArgs;
  args: PlasmicSupportCard__ArgsType;
  overrides: PlasmicSupportCard__OverridesType;

  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const $ctx = ph.useDataEnv?.() || {};
  const args = React.useMemo(
    () =>
      Object.assign(
        {},

        props.args
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  return (
    <div
      data-plasmic-name={"root"}
      data-plasmic-override={overrides.root}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        projectcss.plasmic_tokens,
        sty.root
      )}
    >
      <p.Stack
        as={"div"}
        data-plasmic-name={"badge"}
        data-plasmic-override={overrides.badge}
        hasGap={true}
        className={classNames(projectcss.all, sty.badge)}
      >
        {p.renderPlasmicSlot({
          defaultContents: "Reden und Workshops halten",
          value: args.slot,
          className: classNames(sty.slotTargetSlot)
        })}
      </p.Stack>

      <p.Stack
        as={"div"}
        data-plasmic-name={"card"}
        data-plasmic-override={overrides.card}
        hasGap={true}
        className={classNames(projectcss.all, sty.card)}
      >
        <div
          data-plasmic-name={"freeBox"}
          data-plasmic-override={overrides.freeBox}
          className={classNames(projectcss.all, sty.freeBox)}
        >
          {p.renderPlasmicSlot({
            defaultContents:
              "Menschen müssen organisiert werden, Informationen müssen fliesen ohne die Zeit von anderen Mitgliedern unnötig zu beanspruchen. Ressourcen müssen aufgeteilt werden. Und Checklisten müssen befriedigt werden (hoffentlich nicht ohne die eigentlichen Ziele aus den Augen zu verlieren).\nEvents zu organisieren ist eine Kunst. Du kannst sie mit und üben, lernen und optimieren.\n\nAm Ende kannst du darauf stolz sein, etwas auf die Beine gestellt zu haben und dich an der Dankbarkeit der Teilnehmer erfreuen.",
            value: args.children,
            className: classNames(sty.slotTargetChildren)
          })}
        </div>
      </p.Stack>
    </div>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: ["root", "badge", "card", "freeBox"],
  badge: ["badge"],
  card: ["card", "freeBox"],
  freeBox: ["freeBox"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<
  T extends NodeNameType
> = typeof PlasmicDescendants[T][number];
type NodeDefaultElementType = {
  root: "div";
  badge: "div";
  card: "div";
  freeBox: "div";
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicSupportCard__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> = { // Explicitly specify variants, args, and overrides as objects
  variants?: PlasmicSupportCard__VariantsArgs;
  args?: PlasmicSupportCard__ArgsType;
  overrides?: NodeOverridesType<T>;
} & Omit<PlasmicSupportCard__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
  // Specify args directly as props
  Omit<PlasmicSupportCard__ArgsType, ReservedPropsType> &
  // Specify overrides for each element directly as props
  Omit<
    NodeOverridesType<T>,
    ReservedPropsType | VariantPropType | ArgPropType
  > &
  // Specify props for the root element
  Omit<
    Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
    ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
  >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: [...PlasmicDescendants[nodeName]],
          internalArgPropNames: PlasmicSupportCard__ArgProps,
          internalVariantPropNames: PlasmicSupportCard__VariantProps
        }),
      [props, nodeName]
    );

    return PlasmicSupportCard__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicSupportCard";
  } else {
    func.displayName = `PlasmicSupportCard.${nodeName}`;
  }
  return func;
}

export const PlasmicSupportCard = Object.assign(
  // Top-level PlasmicSupportCard renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    badge: makeNodeComponent("badge"),
    card: makeNodeComponent("card"),
    freeBox: makeNodeComponent("freeBox"),

    // Metadata about props expected for PlasmicSupportCard
    internalVariantProps: PlasmicSupportCard__VariantProps,
    internalArgProps: PlasmicSupportCard__ArgProps
  }
);

export default PlasmicSupportCard;
/* prettier-ignore-end */
